//#include "/Engine/Public/Platform.ush"


//cbuffer CompositeCB
//{
//    float2 OutputSize;
//    float Threshold;
//    float Boost;
//};

//// 资源名保持和 C++ 绑定一致
//Texture2D LowTex;
//SamplerState LowTexSampler;

//Texture2D HighTex;
//SamplerState HighTexSampler;

//Texture2D SalTex;
//SamplerState SalTexSampler;

//RWTexture2D<float4> OutTex;

//[numthreads(8, 8, 1)]
//void MainCS(uint3 DTid : SV_DispatchThreadID)
//{
//    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
//        return;

//    float2 uv = (float2(DTid.xy) + 0.5) / OutputSize;

//    float4 lowC = LowTex.SampleLevel(LowTexSampler, uv, 0);
//    float4 highC = HighTex.SampleLevel(HighTexSampler, uv, 0);
//    float s = SalTex.SampleLevel(SalTexSampler, uv, 0).r;

//    // 简单权重： (s - Threshold) * Boost → [0,1]
//    float w = saturate((s - Threshold) * Boost);
//    OutTex[DTid.xy] = lerp(lowC, highC, w);
//}


#include "/Engine/Public/Platform.ush"

cbuffer CompositeCB
{
    float2 OutputSize;
    float Threshold;
    float Boost;
};

Texture2D LowTex;
SamplerState LowTexSampler;
Texture2D HighTex;
SamplerState HighTexSampler;
Texture2D SalTex;
SamplerState SalTexSampler;

RWTexture2D<float4> OutTex;

[numthreads(8, 8, 1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
        return;

    // 先用纯色验证写入路径正确
    //OutTex[DTid.xy] = float4(1, 0, 1, 1);

    // 再恢复真正逻辑
    float2 uv = (float2(DTid.xy) + 0.5) / OutputSize;
    float4 lowC = LowTex.SampleLevel(LowTexSampler, uv, 0);
    float4 highC = HighTex.SampleLevel(HighTexSampler, uv, 0);
    float s = SalTex.SampleLevel(SalTexSampler, uv, 0).r;
    float w = saturate((s - Threshold) * Boost);
    OutTex[DTid.xy] = lerp(lowC, highC, w);
}
