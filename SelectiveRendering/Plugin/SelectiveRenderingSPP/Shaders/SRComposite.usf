//// /SelectiveRenderingSPP/SRComposite.usf

//RWTexture2D<float4> OutTex;

//Texture2D LowTex;
//SamplerState LowTexSampler;

//Texture2D HighTex;
//SamplerState HighTexSampler;

//Texture2D SalTex;
//SamplerState SalTexSampler;

//cbuffer Params
//{
//    float2 OutputSize;
//    float Threshold;
//    float Boost;
//};

////[numthreads(8, 8, 1)]
////void MainCS(uint3 DTid : SV_DispatchThreadID)
////{
////    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
////        return;

////    float2 uv = (DTid.xy + 0.5) / OutputSize;

////    float3 lo = LowTex.SampleLevel(LowTexSampler, uv, 0).rgb;
////    float3 hi = HighTex.SampleLevel(HighTexSampler, uv, 0).rgb;

////    // 用显著图控制混合强度（越亮越偏向 hi）
////    float sal = SalTex.SampleLevel(SalTexSampler, uv, 0).r;
////    float w = saturate(sal - Threshold); // 也可用 smoothstep(Threshold, Threshold+0.1, sal);

////    float3 c = lerp(lo, hi, w);

////    // Boost 用来整体提亮或缩放
////    OutTex[DTid.xy] = float4(c * Boost, 1);
////}


//[numthreads(8, 8, 1)]
//void maincs(uint3 dtid : sv_dispatchthreadid)
//{
//    // 可能会发到对齐后的工作组，因此要做越界保护
//    if (dtid.x >= outputsize.x || dtid.y >= outputsize.y)
//        return;

//    // 洋红填充，用来验证 usf 是否在跑
//    outtex[dtid.xy] = float4(1, 0, 1, 1);
//}




//// /SelectiveRenderingSPP/SRComposite.usf

//// 打开=1 时强制输出洋红；关=0 时走正式逻辑
//#define SPP_TEST_MAGENTA 1

//RWTexture2D<float4> OutTex;

//Texture2D LowTex;
//SamplerState LowTexSampler;
//Texture2D HighTex;
//SamplerState HighTexSampler;
//Texture2D SalTex;
//SamplerState SalTexSampler;

//cbuffer Parameters     // ← 名字必须叫 Parameters
//{
//    float2 OutputSize;
//    float Threshold;
//    float Boost;
//};

//[numthreads(8, 8, 1)]
//void MainCS(uint3 DTid : SV_DispatchThreadID)
//{
//    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
//        return;

//#if SPP_TEST_MAGENTA
//    OutTex[DTid.xy] = float4(1, 0, 1, 1);
//#else
//    float2 uv = (DTid.xy + 0.5) / OutputSize;

//    float3 lo  = LowTex .SampleLevel(LowTexSampler , uv, 0).rgb;
//    float3 hi  = HighTex.SampleLevel(HighTexSampler, uv, 0).rgb;
//    float  sal = SalTex .SampleLevel(SalTexSampler , uv, 0).r;

//    float  w = saturate(sal - Threshold);
//    float3 c = lerp(lo, hi, w);

//    OutTex[DTid.xy] = float4(c * Boost, 1);
//#endif
//}


//// /SelectiveRenderingSPP/SRComposite.usf

//// 调试开关
//#define SPP_TEST_MAGENTA 1

//RWTexture2D<float4> OutTex;

//Texture2D LowTex;
//SamplerState LowTexSampler;

//Texture2D HighTex;
//SamplerState HighTexSampler;

//Texture2D SalTex;
//SamplerState SalTexSampler;

//float2 OutputSize;
//float Threshold;
//float Boost;

//[numthreads(8, 8, 1)]
//void MainCS(uint3 DTid : SV_DispatchThreadID)
//{
//    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
//        return;

//#if SPP_TEST_MAGENTA
//    OutTex[DTid.xy] = float4(1, 0, 1, 1);
//#else
//    float2 uv = (DTid.xy + 0.5) / OutputSize;
//    float3 lo = LowTex.SampleLevel(LowTexSampler, uv, 0).rgb;
//    float3 hi = HighTex.SampleLevel(HighTexSampler, uv, 0).rgb;
//    float sal = SalTex.SampleLevel(SalTexSampler, uv, 0).r;
//    float w = saturate(sal - Threshold);
//    float3 c = lerp(lo, hi, w);
//    OutTex[DTid.xy] = float4(c * Boost, 1);
//#endif
//}


// Plugins/SelectiveRenderingSPP/Shaders/SRComposite.usf
#include "/Engine/Public/Platform.ush"
#include "/Engine/Public/ShaderCommon.ush"

RWTexture2D<float4> OutTex;

Texture2D<float4> LowTex;
SamplerState LowTexSampler;

Texture2D<float4> HighTex;
SamplerState HighTexSampler;

Texture2D<float> SalTex; // 如果是灰度图；若也是 RGBA 就用 float4
SamplerState SalTexSampler;

cbuffer Parameters
{
    float2 OutputSize;
    float Threshold;
    float Boost;
};

[numthreads(8, 8, 1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
        return;

    float2 uv = (DTid.xy + 0.5) / OutputSize;
    float4 lo = LowTex.SampleLevel(LowTexSampler, uv, 0);
    float4 hi = HighTex.SampleLevel(HighTexSampler, uv, 0);
    float s = SalTex.SampleLevel(SalTexSampler, uv, 0);
    float w = (s > Threshold) ? Boost : 0.0;

    OutTex[DTid.xy] = lerp(lo, hi, saturate(w));
}


