// /SelectiveRenderingSPP/SRComposite.usf

RWTexture2D<float4> OutTex;

Texture2D LowTex;
SamplerState LowTexSampler;

Texture2D HighTex;
SamplerState HighTexSampler;

Texture2D SalTex;
SamplerState SalTexSampler;

cbuffer Params
{
    float2 OutputSize;
    float Threshold;
    float Boost;
};

//[numthreads(8, 8, 1)]
//void MainCS(uint3 DTid : SV_DispatchThreadID)
//{
//    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
//        return;

//    float2 uv = (DTid.xy + 0.5) / OutputSize;

//    float3 lo = LowTex.SampleLevel(LowTexSampler, uv, 0).rgb;
//    float3 hi = HighTex.SampleLevel(HighTexSampler, uv, 0).rgb;

//    // 用显著图控制混合强度（越亮越偏向 hi）
//    float sal = SalTex.SampleLevel(SalTexSampler, uv, 0).r;
//    float w = saturate(sal - Threshold); // 也可用 smoothstep(Threshold, Threshold+0.1, sal);

//    float3 c = lerp(lo, hi, w);

//    // Boost 用来整体提亮或缩放
//    OutTex[DTid.xy] = float4(c * Boost, 1);
//}

[numthreads(8, 8, 1)]
void MainCS(uint3 DTid : SV_DispatchThreadID)
{
    // 可能会发到对齐后的工作组，因此要做越界保护
    if (DTid.x >= OutputSize.x || DTid.y >= OutputSize.y)
        return;

    // 洋红填充，用来验证 usf 是否在跑
    OutTex[DTid.xy] = float4(1, 0, 1, 1);
}
